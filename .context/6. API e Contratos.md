## 1. Contratos REST (Endpoints)

### **Endpoint: `POST /api/auth/login`**
- **Método**: POST
- **Descrição**: Autentica um usuário e retorna um token JWT.
- **Headers**: `Content-Type: application/json`
- **Payload esperado**:
  ```json
  {
    "email": "string",
    "password": "string"
  }
  ```
- **Validação Zod**:
  ```ts
  const LoginSchema = z.object({
    email: z.string().email("Formato de email inválido"),
    password: z.string().min(1, "Senha é obrigatória"),
  });
  ```
- **Response 200**:
  ```json
  {
    "success": true,
    "data": {
      "token": "string",
      "user": {
        "id": "uuid",
        "email": "string",
        "isAdm": "boolean",
        "tenantId": "uuid"
      }
    }
  }
  ```
- **Response 400**:
  ```json
  {
    "success": false,
    "error": "INVALID_CREDENTIALS",
    "message": "Credenciais inválidas"
  }
  ```
- **Response 401**:
  ```json
  {
    "success": false,
    "error": "ACCOUNT_LOCKED",
    "message": "Conta temporariamente bloqueada devido a tentativas de login falhas."
  }
  ```
- **Rate Limiting**: 5 tentativas por IP a cada 15 minutos (exemplo).
- **Headers de Segurança**: `Authorization: Bearer <token>` (para endpoints protegidos).
- **Testes de Contrato**:
  - ✅ Payload válido → 200 OK com token e dados do usuário
  - ❌ Email inválido → 400 Bad Request
  - ❌ Senha vazia → 400 Bad Request
  - ❌ Credenciais incorretas → 400 Bad Request
  - ❌ Excesso de tentativas → 401 Unauthorized

### **Endpoint: `GET /api/auth/me`**
- **Método**: GET
- **Descrição**: Retorna os dados do usuário autenticado.
- **Headers**: `Authorization: Bearer <token>`
- **Payload esperado**: Nenhum
- **Response 200**:
  ```json
  {
    "success": true,
    "data": {
      "id": "uuid",
      "email": "string",
      "isAdm": "boolean",
      "tenantId": "uuid"
    }
  }
  ```
- **Response 401**:
  ```json
  {
    "success": false,
    "error": "UNAUTHORIZED",
    "message": "Token inválido ou expirado"
  }
  ```
- **Rate Limiting**: 100 req/min por usuário (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido → 200 OK com dados do usuário
  - ❌ Token ausente → 401 Unauthorized
  - ❌ Token inválido/expirado → 401 Unauthorized

### **Endpoint: `POST /api/auth/forgot-password`**
- **Método**: POST
- **Descrição**: Solicita redefinição de senha.
- **Headers**: `Content-Type: application/json`
- **Payload esperado**:
  ```json
  {
    "email": "string"
  }
  ```
- **Validação Zod**:
  ```ts
  const ForgotPasswordSchema = z.object({
    email: z.string().email("Formato de email inválido"),
  });
  ```
- **Response 200**:
  ```json
  {
    "success": true,
    "message": "Se o email estiver registrado, um link de redefinição foi enviado."
  }
  ```
- **Response 400**:
  ```json
  {
    "success": false,
    "error": "INVALID_EMAIL_FORMAT",
    "message": "Formato de email inválido"
  }
  ```
- **Rate Limiting**: 3 req/h por IP.
- **Testes de Contrato**:
  - ✅ Email válido → 200 OK com mensagem genérica
  - ❌ Email inválido → 400 Bad Request

### **Endpoint: `GET /api/users`**
- **Método**: GET
- **Descrição**: Lista usuários do tenant do usuário autenticado. Requer permissão de administrador (`isAdm`).
- **Headers**: `Authorization: Bearer <token>`
- **Query Parameters (opcional)**: `page`, `limit`, `search`
- **Response 200**:
  ```json
  {
    "success": true,
    "data": [
      {
        "id": "uuid",
        "email": "string",
        "firstName": "string",
        "lastName": "string",
        "isAdm": "boolean",
        "createdAt": "datetime"
      }
    ],
    "pagination": {
      "page": "integer",
      "limit": "integer",
      "total": "integer",
      "totalPages": "integer"
    }
  }
  ```
- **Response 401**:
  ```json
  {
    "success": false,
    "error": "UNAUTHORIZED",
    "message": "Acesso negado. Token inválido ou expirado."
  }
  ```
- **Response 403**:
  ```json
  {
    "success": false,
    "error": "FORBIDDEN",
    "message": "Acesso negado. Permissões insuficientes."
  }
  ```
- **Rate Limiting**: 50 req/min por usuário administrativo (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido + é admin → 200 OK com lista de usuários
  - ❌ Token inválido → 401 Unauthorized
  - ❌ Token válido + NÃO é admin → 403 Forbidden
  - ❌ Limite de requisições excedido → 429 Too Many Requests

### **Endpoint: `POST /api/users`**
- **Método**: POST
- **Descrição**: Cria um novo usuário no tenant do usuário autenticado. Requer permissão de administrador (`isAdm`).
- **Headers**: `Authorization: Bearer <token>`, `Content-Type: application/json`
- **Payload esperado**:
  ```json
  {
    "email": "string",
    "firstName": "string",
    "lastName": "string",
    "password": "string",
    "isAdm": "boolean"
  }
  ```
- **Validação Zod**:
  ```ts
  const CreateUserSchema = z.object({
    email: z.string().email("Formato de email inválido"),
    firstName: z.string().min(1, "Nome é obrigatório"),
    lastName: z.string().min(1, "Sobrenome é obrigatório"),
    password: z.string().min(8, "Senha deve ter pelo menos 8 caracteres"),
    isAdm: z.boolean().default(false),
  });
  ```
- **Response 201**:
  ```json
  {
    "success": true,
    "data": {
      "id": "uuid",
      "email": "string",
      "firstName": "string",
      "lastName": "string",
      "isAdm": "boolean",
      "createdAt": "datetime"
    }
  }
  ```
- **Response 400**:
  ```json
  {
    "success": false,
    "error": "VALIDATION_ERROR",
    "message": "Erro de validação nos dados fornecidos.",
    "details": { ... }
  }
  ```
- **Rate Limiting**: 10 req/h por usuário administrativo (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido + é admin + payload válido → 201 Created com dados do usuário
  - ❌ Token inválido → 401 Unauthorized
  - ❌ Token válido + NÃO é admin → 403 Forbidden
  - ❌ Payload inválido (email, senha curta) → 400 Bad Request

### **Endpoint: `PUT /api/users/{id}`**
- **Método**: PUT
- **Descrição**: Atualiza os dados de um usuário existente no tenant. Requer permissão de administrador (`isAdm`).
- **Headers**: `Authorization: Bearer <token>`, `Content-Type: application/json`
- **Payload esperado** (parcial):
  ```json
  {
    "firstName": "string",
    "lastName": "string",
    "password": "string", // Opcional
    "isAdm": "boolean"
  }
  ```
- **Validação Zod**:
  ```ts
  const UpdateUserSchema = z.object({
    firstName: z.string().min(1, "Nome é obrigatório").optional(),
    lastName: z.string().min(1, "Sobrenome é obrigatório").optional(),
    password: z.string().min(8, "Senha deve ter pelo menos 8 caracteres").optional(),
    isAdm: z.boolean().optional(),
  });
  ```
- **Response 200**:
  ```json
  {
    "success": true,
    "data": {
      "id": "uuid",
      "email": "string",
      "firstName": "string",
      "lastName": "string",
      "isAdm": "boolean",
      "updatedAt": "datetime"
    }
  }
  ```
- **Rate Limiting**: 20 req/min por usuário administrativo (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido + é admin + payload parcial válido → 200 OK com dados atualizados
  - ❌ Token inválido → 401 Unauthorized
  - ❌ Token válido + NÃO é admin → 403 Forbidden
  - ❌ Payload inválido (senha curta) → 400 Bad Request

### **Endpoint: `DELETE /api/users/{id}`**
- **Método**: DELETE
- **Descrição**: Remove um usuário do tenant. Requer permissão de administrador (`isAdm`).
- **Headers**: `Authorization: Bearer <token>`
- **Response 204**: `No Content`
- **Response 401**: (como acima)
- **Response 403**: (como acima)
- **Rate Limiting**: 5 req/min por usuário administrativo (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido + é admin + ID existente → 204 No Content
  - ❌ Token inválido → 401 Unauthorized
  - ❌ Token válido + NÃO é admin → 403 Forbidden
  - ❌ ID inexistente → 404 Not Found (ou 204, dependendo da estratégia)

### **Endpoint: `GET /api/metrics`**
- **Método**: GET
- **Descrição**: Retorna métricas observáveis do tenant do usuário autenticado.
- **Headers**: `Authorization: Bearer <token>`
- **Query Parameters**: `tenantId` (opcional para admin), `metricName`, `from`, `to`
- **Response 200**:
  ```json
  {
    "success": true,
    "data": [
      {
        "id": "uuid",
        "tenantId": "uuid",
        "metricName": "string", // ex: 'time_response_per_tenant'
        "value": "numeric",
        "timestamp": "datetime",
        "labels": "jsonb" // ex: {"endpoint": "/api/users", "status_code": 200}
      }
    ]
  }
  ```
- **Rate Limiting**: 200 req/min por usuário (exemplo).
- **Testes de Contrato**:
  - ✅ Token válido + filtros válidos → 200 OK com lista de métricas
  - ❌ Token inválido → 401 Unauthorized
  - ❌ Filtros inválidos (ex: `from` > `to`) → 400 Bad Request
  - ❌ Acesso a métricas de outro tenant (sem ser admin) → 403 Forbidden (garantido pelo RLS)

## 2. Contratos WebSocket (Eventos)

*(Não são mencionados explicitamente no PDR fornecido, mas podem ser úteis para atualizações de métricas em tempo real no dashboard.)*

### **Evento: `metric_update`**
- **Descrição**: Envia atualizações de métricas em tempo real para o frontend.
- **Payload**:
  ```json
  {
    "metricName": "string", // ex: 'time_response_per_tenant'
    "value": "numeric",
    "timestamp": "datetime",
    "labels": "jsonb"
  }
  ```
- **Frequência**: Configurável, ex: a cada 10 segundos ou quando um threshold é atingido.
- **Requisitos**: Conexão WebSocket autenticada com token JWT.
- **Testes de Contrato**:
  - ✅ Conexão autenticada → evento `metric_update` recebido periodicamente
  - ❌ Token inválido na conexão inicial → conexão rejeitada

## 3. Integração com Frontend

### **Hook: `useAuth()`**
- **Descrição**: Hook customizado para gerenciar o estado de autenticação (login, logout, dados do usuário).
- **Dependências**: TanStack Query para cache e sincronização de dados.
- **Métodos**:
  - `login(email: string, password: string)`: Chama `POST /api/auth/login`, armazena o token e os dados do usuário.
  - `logout()`: Remove o token e invalida o cache de dados protegidos.
  - `me()`: Chama `GET /api/auth/me` e retorna os dados do usuário.
- **Estados Gerenciados**:
  - `data`: Dados do usuário (id, email, isAdm, tenantId).
  - `isPending`: Indicador de carregamento (login, fetch do usuário).
  - `error`: Erros de autenticação.
  - `isAuthenticated`: Booleano indicando se o usuário está autenticado.
- **Testes de Contrato** (Frontend):
  - ✅ Chamada `login` com credenciais válidas → `isAuthenticated` true, dados do usuário carregados.
  - ❌ Chamada `login` com credenciais inválidas → `error` exibido, `isAuthenticated` false.
  - ✅ Chamada `logout` → token removido, cache limpo, redirecionamento para login.

### **Hook: `useUsers()`**
- **Descrição**: Hook para gerenciar a listagem, criação, atualização e exclusão de usuários.
- **Dependências**: TanStack Query para fetching, mutations e cache.
- **Funções**:
  - `useGetUsers()`: `GET /api/users` - Retorna lista de usuários e estado de loading/error.
  - `useCreateUser()`: `POST /api/users` - Retorna função mutate para criar usuário.
  - `useUpdateUser()`: `PUT /api/users/{id}` - Retorna função mutate para atualizar usuário.
  - `useDeleteUser()`: `DELETE /api/users/{id}` - Retorna função mutate para excluir usuário.
- **Estados Gerenciados**:
  - `data`: Lista de usuários (para `useGetUsers`).
  - `isPending`, `error`: Para todas as operações.
  - `isSuccess`: Para indicar sucesso em criação/atualização/exclusão.
- **Testes de Contrato** (Frontend):
  - ✅ Chamada `useGetUsers` (como admin) → lista de usuários exibida.
  - ✅ Chamada `useCreateUser.mutate` → usuário adicionado à lista após sucesso.
  - ✅ Chamada `useDeleteUser.mutate` → usuário removido da lista após sucesso.

### **Hook: `useMetrics()`**
- **Descrição**: Hook para buscar e exibir métricas no dashboard.
- **Dependências**: TanStack Query para fetching e cache.
- **Funções**:
  - `useGetMetrics(params)`: `GET /api/metrics` - Retorna dados das métricas e estado de loading/error.
- **Estados Gerenciados**:
  - `data`: Array de métricas.
  - `isPending`, `error`: Estado da requisição.
- **Testes de Contrato** (Frontend):
  - ✅ Chamada `useGetMetrics` com filtros válidos → gráficos e cards atualizados com dados.

## 4. Documentação Swagger/OpenAPI (Opcional)

```yaml
openapi: 3.0.0
info:
  title: Kaven Boilerplate API
  version: 1.0.0
  description: API para o painel administrativo multi-tenant.
servers:
  - url: http://localhost:3010/api
    description: Servidor de desenvolvimento

paths:
  /auth/login:
    post:
      summary: Autentica um usuário
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: Login bem-sucedido
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LoginResponse'
        '400':
          description: Credenciais inválidas
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '401':
          description: Conta bloqueada
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /users:
    get:
      summary: Lista usuários do tenant
      security:
        - bearerAuth: []
      parameters:
        - name: page
          in: query
          schema:
            type: integer
        - name: limit
          in: query
          schema:
            type: integer
      responses:
        '200':
          description: Lista de usuários
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UsersListResponse'
        '401':
          description: Não autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '403':
          description: Proibido (não é admin)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

    post:
      summary: Cria um novo usuário
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateUserRequest'
      responses:
        '201':
          description: Usuário criado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateUserResponse'
        '400':
          description: Erro de validação
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '401':
          description: Não autorizado
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '403':
          description: Proibido (não é admin)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    LoginRequest:
      type: object
      required:
        - email
        - password
      properties:
        email:
          type: string
          format: email
        password:
          type: string
          minLength: 1
    LoginResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          type: object
          properties:
            token:
              type: string
            user:
              $ref: '#/components/schemas/User'
    ErrorResponse:
      type: object
      properties:
        success:
          type: boolean
        error:
          type: string
        message:
          type: string
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        isAdm:
          type: boolean
        tenantId:
          type: string
          format: uuid
    UsersListResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          type: array
          items:
            $ref: '#/components/schemas/User'
    CreateUserRequest:
      type: object
      required:
        - email
        - firstName
        - lastName
        - password
      properties:
        email:
          type: string
          format: email
        firstName:
          type: string
          minLength: 1
        lastName:
          type: string
          minLength: 1
        password:
          type: string
          minLength: 8
        isAdm:
          type: boolean
    CreateUserResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          $ref: '#/components/schemas/User'
```

## 5. Testes de Contrato

### **Teste: `POST /api/auth/login`**
```ts
import { describe, it, expect, beforeAll } from 'vitest';
import request from 'supertest';
import app from '../src/app'; // Sua aplicação Fastify

describe('POST /api/auth/login', () => {
  it('should login user with valid credentials and return token', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'admin@example.com', // Exemplo de usuário existente
        password: 'Password123!',    // Exemplo de senha válida
      });

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.data).toHaveProperty('token');
    expect(response.body.data).toHaveProperty('user');
    expect(response.body.data.user).toHaveProperty('id');
    expect(response.body.data.user).toHaveProperty('email');
  });

  it('should return 400 for invalid email format', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'invalid-email',
        password: 'Password123!',
      });

    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBe('INVALID_EMAIL_FORMAT');
  });

  it('should return 400 for incorrect credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'nonexistent@example.com',
        password: 'WrongPassword!',
      });

    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBe('INVALID_CREDENTIALS');
  });
});
```

### **Teste: `GET /api/users` (Autenticado como Admin)**
```ts
import { describe, it, expect, beforeAll } from 'vitest';
import request from 'supertest';
import app from '../src/app';

let authToken: string;

beforeAll(async () => {
  // Autentica um usuário admin para usar nos testes
  const loginResponse = await request(app)
    .post('/api/auth/login')
    .send({
      email: 'admin@example.com',
      password: 'Password123!',
    });
  authToken = loginResponse.body.data.token;
});

describe('GET /api/users', () => {
  it('should return list of users for authenticated admin', async () => {
    const response = await request(app)
      .get('/api/users')
      .set('Authorization', `Bearer ${authToken}`);

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(Array.isArray(response.body.data)).toBe(true);
    // Adicione verificações específicas para os campos dos usuários
    if (response.body.data.length > 0) {
      expect(response.body.data[0]).toHaveProperty('id');
      expect(response.body.data[0]).toHaveProperty('email');
      expect(response.body.data[0]).toHaveProperty('isAdm');
    }
  });

  it('should return 401 for unauthenticated request', async () => {
    const response = await request(app)
      .get('/api/users');

    expect(response.status).toBe(401);
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBe('UNAUTHORIZED');
  });
});
```