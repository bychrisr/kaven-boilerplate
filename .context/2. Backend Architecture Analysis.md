## 1. Entities

### Tenant
- **Campos:**
  - `id: UUID, PK, NOT NULL, DEFAULT gen_random_uuid()`
  - `name: VARCHAR(255), NOT NULL, UNIQUE`
  - `subdomain: VARCHAR(255), NOT NULL, UNIQUE`
  - `created_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
  - `updated_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
  - `[ASSUMPTION]`: Pode haver outros campos como `status` (ex: 'active', 'suspended'), `settings` JSONB, mas não são especificados no PDR.
- **Observações:** Nome e subdomínio devem ser únicos para garantir isolamento de tenants.

### User
- **Campos:**
  - `id: UUID, PK, NOT NULL, DEFAULT gen_random_uuid()`
  - `tenant_id: UUID, FK NOT NULL, REFERENCES tenants(id)`
  - `email: VARCHAR(255), NOT NULL, UNIQUE`
  - `password_hash: VARCHAR(255), NOT NULL`
  - `first_name: VARCHAR(255)`
  - `last_name: VARCHAR(255)`
  - `is_adm: BOOLEAN, NOT NULL, DEFAULT FALSE` (único campo com esta flag, conforme PDR)
  - `created_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
  - `updated_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
- **Observações:** A senha é armazenada como hash. A flag `is_adm` define o papel administrativo dentro do tenant.

### Plan
- **Campos:**
  - `id: UUID, PK, NOT NULL, DEFAULT gen_random_uuid()`
  - `name: VARCHAR(255), NOT NULL, UNIQUE`
  - `description: TEXT`
  - `features: JSONB` (ex: quotas, limites)
  - `price: DECIMAL(10, 2)`
  - `created_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
  - `updated_at: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
- **Observações:** Armazena os planos de assinatura com detalhes de recursos e preços.

### Metric
- **Campos:**
  - `id: UUID, PK, NOT NULL, DEFAULT gen_random_uuid()`
  - `tenant_id: UUID, FK NOT NULL, REFERENCES tenants(id)`
  - `metric_name: VARCHAR(255), NOT NULL` (ex: 'time_response', 'errors', 'queue_length', 'cpu_usage')
  - `value: NUMERIC, NOT NULL`
  - `timestamp: TIMESTAMPTZ, NOT NULL, DEFAULT NOW()`
  - `labels: JSONB` (ex: tags adicionais para filtragem, como o nome do endpoint)
- **Observações:** Tabela para armazenar métricas por tenant, usada para observabilidade e alertas. O schema reflete os nomes de métricas mencionados no PDR.

## 2. Relationships

- **User -> Tenant (N:1)**
  - Tipo: N:1
  - `FK: user.tenant_id -> tenant.id`
  - Ação em cascata: `[ASSUMPTION]` `ON DELETE CASCADE` para deletar usuários se o tenant for removido, ou `ON DELETE SET NULL` se for necessário manter histórico. O PDR não especifica.
  - **Observações:** Vincula cada usuário a um tenant específico.

- **Outros relacionamentos:** Não são especificados no PDR fornecido.

## 3. API Endpoints (previstos)

*[ASSUMPTION]* A estrutura de endpoints seguirá as práticas comuns para um backend RESTful com autenticação JWT.

- **Rota:** `POST /api/auth/login`
  - **Método:** POST
  - **Payload esperado (JSON):** `{ "email": "string", "password": "string" }`
  - **Response (JSON):** `{ "success": true, "data": { "token": "string", "user": { "id": "uuid", "email": "string", "isAdm": "boolean", "tenantId": "uuid" } } }`
  - **Auth/Permissões:** Público
  - **Rate Limiting:** `[ASSUMPTION]` Exemplo: 5 tentativas por IP a cada 15 minutos.
  - **Validação de Input:** Verificação de formato de e-mail e comprimento mínimo da senha.

- **Rota:** `GET /api/users/me`
  - **Método:** GET
  - **Payload esperado (JSON):** Nenhum
  - **Response (JSON):** `{ "success": true, "data": { "id": "uuid", "email": "string", "isAdm": "boolean", "tenantId": "uuid" } }`
  - **Auth/Permissões:** JWT obrigatório, scope: `user:read`
  - **Rate Limiting:** `[ASSUMPTION]` Exemplo: 100 req/min por usuário.
  - **Validação de Input:** Nenhuma.

- **Rota:** `GET /api/tenants`
  - **Método:** GET
  - **Payload esperado (JSON):** Nenhum
  - **Response (JSON):** `{ "success": true, "data": [{ "id": "uuid", "name": "string", "subdomain": "string" }] }`
  - **Auth/Permissões:** JWT obrigatório, scope: `tenant:read`, permissão de administrador (`isAdm`).
  - **Rate Limiting:** `[ASSUMPTION]` Exemplo: 50 req/min por usuário administrativo.
  - **Validação de Input:** Nenhuma.

- **Rota:** `POST /api/tenants`
  - **Método:** POST
  - **Payload esperado (JSON):** `{ "name": "string", "subdomain": "string" }`
  - **Response (JSON):** `{ "success": true, "data": { "id": "uuid", "name": "string", "subdomain": "string" } }`
  - **Auth/Permissões:** JWT obrigatório, scope: `tenant:create`, permissão de administrador (`isAdm`).
  - **Rate Limiting:** `[ASSUMPTION]` Exemplo: 10 req/hour por usuário administrativo.
  - **Validação de Input:** Verificação de unicidade de `name` e `subdomain`.

- **Rota:** `GET /api/metrics`
  - **Método:** GET
  - **Payload esperado (JSON):** `{ "tenantId": "uuid", "metricName": "string", "from": "timestamp", "to": "timestamp" }` (parâmetros de query)
  - **Response (JSON):** `{ "success": true, "data": [{ "timestamp": "timestamp", "value": "numeric", "labels": "jsonb" }] }`
  - **Auth/Permissões:** JWT obrigatório, scope: `metric:read`, RLS aplicada (usuário só pode ler métricas do seu tenant, exceto admins).
  - **Rate Limiting:** `[ASSUMPTION]` Exemplo: 200 req/min por usuário.
  - **Validação de Input:** Verificação de formato e validade dos timestamps `from` e `to`.

## 4. Business Rules

- **Quotas & Cost Control:** Não são detalhadas no PDR do Kaven Boilerplate.
- **Pipeline Orchestration:** O PDR menciona "workers assíncronos", mas não detalha o tipo de processamento ou orquestração específica (ex: BullMQ). `[ASSUMPTION]` Pode-se usar uma biblioteca como BullMQ com Redis para gerenciar filas e workers para tarefas assíncronas.
- **Embedding & Semantic Search:** Não aplicável ao Kaven Boilerplate.
- **Segurança:**
  - Autenticação: JWT com escopos (não detalhado no PDR, mas implícito).
  - Hashing de senha: `[ASSUMPTION]` Usar bcrypt ou argon2.
  - Políticas de senha: Mínima complexidade e comprimento (definido no PDR).
  - Rate limiting: Multi-camada (definido no PDR).
  - Proteção contra ataques: XSS, SQL injection, CSRF (definido no PDR).
  - RLS: Ativado no PostgreSQL (definido no PDR).
  - Logs de auditoria: Detalhados (definido no PDR).
  - 2FA: Preparado para integração futura (definido no PDR, opcional para MVP).
- **Observabilidade:** Métricas mínimas (`time_response_per_tenant`, `errors_per_tenant`, `queue_length_per_tenant`, `cpu_usage_per_tenant`), dashboards Grafana, alertas, runbooks (definido no PDR).
- **Governança de Dados:** RLS para isolamento, seeds iniciais, políticas de segurança (definido no PDR).

## 5. Validations

- **Por entidade:**
  - `Tenant.name`: Obrigatório, único, tamanho máximo.
  - `Tenant.subdomain`: Obrigatório, único, formato válido (ex: regex para subdomínio).
  - `User.email`: Obrigatório, único, formato de e-mail válido.
  - `User.password`: Obrigatório, cumprir políticas mínimas de complexidade.
  - `User.tenant_id`: Deve existir na tabela `tenants`.
  - `Metric.tenant_id`: Deve existir na tabela `tenants`.
  - `Metric.metric_name`: Obrigatório, valor deve estar na lista definida (ou seguir um padrão).
- **Sanitização:** Não aplicável a campos simples como os descritos. Sanitização seria mais relevante para campos de texto longo.
- **Validação de arquivos:** Não aplicável ao escopo descrito.
- **Testes de Contrato:** `[ASSUMPTION]` Usar JSON Schema para validar payloads de entrada e saída dos endpoints e workers.

## 6. Critical Flows

- **Fluxos como:** O PDR não detalha fluxos críticos específicos além da estrutura multi-tenant e observabilidade. `[ASSUMPTION]` Fluxos genéricos de login, criação de tenant, e leitura de métricas são esperados.
  - **Workers envolvidos:** Não especificados.
  - **Filas e prioridades:** Não especificadas.
  - **Retry Logic:** Não especificado.
  - **Timeouts por etapa:** Não especificados.
  - **Observabilidade:** Métricas e logs para endpoints e workers.
  - **Fallback e notificação ao usuário:** Não especificados.

## 7. Security & Observability

- **Autenticação:** JWT (tempo de vida e refresh token não definidos no PDR, `[ASSUMPTION]` seguir práticas recomendadas).
- **Autorização:** Middleware de autenticação + RLS no PostgreSQL (definido no PDR).
- **Criptografia:**
  - Em trânsito: TLS 1.3 (implícito para serviços web).
  - Em repouso: PostgreSQL encryption, AES-256-GCM para secrets (definido no PDR como `[ASSUMPTION]`).
- **Rate Limiting:** Redis + sliding window, por endpoint e/ou usuário/IP (definido no PDR).
- **Input Sanitization:** Queries parametrizadas (definido no PDR como proteção contra SQL injection).
- **Logs:** Estruturados, sem dados sensíveis (definido no PDR).
- **Métricas:** Prometheus (definido no PDR), Grafana dashboards (definido no PDR).
- **Health Checks:** `[ASSUMPTION]` Endpoint `/health` para verificar status de DB, Redis, workers.
- **Compliance:** Logs de auditoria detalhados (definido no PDR).

## 8. Preventable Issues Checklist

✅ Sanitização de inputs (SQL injection mencionado) desde o início
✅ Criptografia de dados sensíveis configurada (menção no PDR)
✅ Headers de segurança (XSS, CSRF mencionados)
✅ Rate limiting por usuário + IP (definido no PDR)
✅ Logs estruturados sem dados sensíveis (definido no PDR)
✅ Testes de contrato para workers e endpoints ([ASSUMPTION] implícito)
✅ Métricas de performance e erro monitoradas (definido no PDR)
✅ Health checks para todos os serviços ([ASSUMPTION] implícito)
✅ Configuração de ambiente (dev/staging/prod) separada ([ASSUMPTION] implícito)

## 9. Worker Contracts (JSON Schema)

- **Esquemas de entrada/saída para cada worker:** Não definidos no PDR do Kaven Boilerplate.

## 10. Database Schema (PostgreSQL)

- **DDL completo:**
```sql
-- Extensão pgvector não é necessária para o Kaven Boilerplate, conforme PDR.
-- Extensões usadas: uuid-ossp (para gen_random_uuid), se não estiver ativada por padrão.

CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    subdomain VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    features JSONB, -- Ex: {"max_users": 10, "storage_gb": 5}
    price DECIMAL(10, 2),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    is_adm BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    metric_name VARCHAR(255) NOT NULL,
    value NUMERIC NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    labels JSONB -- Ex: {"endpoint": "/api/users", "status_code": 200}
);

-- Índices
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_metrics_tenant_id ON metrics(tenant_id);
CREATE INDEX idx_metrics_metric_name ON metrics(metric_name);
CREATE INDEX idx_metrics_timestamp ON metrics(timestamp);
-- Índice para busca em labels JSONB (GIN) pode ser útil
CREATE INDEX idx_metrics_labels ON metrics USING GIN (labels);

-- Row-Level Security (RLS)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE metrics ENABLE ROW LEVEL SECURITY;

-- Política de RLS: Usuários só veem dados do seu tenant
CREATE POLICY user_tenant_isolation_policy ON users
    FOR ALL
    TO authenticated_user_role
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);

CREATE POLICY metric_tenant_isolation_policy ON metrics
    FOR ALL
    TO authenticated_user_role
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);

-- Administradores (is_adm = true) podem ver todos os dados
CREATE POLICY admin_user_full_access_policy ON users
    FOR ALL
    TO authenticated_user_role
    USING (EXISTS (SELECT 1 FROM users u WHERE u.id = current_setting('app.current_user_id')::UUID AND u.is_adm = true));

CREATE POLICY admin_metric_full_access_policy ON metrics
    FOR ALL
    TO authenticated_user_role
    USING (EXISTS (SELECT 1 FROM users u WHERE u.id = current_setting('app.current_user_id')::UUID AND u.is_adm = true));

-- Trigger para atualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tenants_updated_at BEFORE UPDATE ON tenants FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_plans_updated_at BEFORE UPDATE ON plans FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_metrics_updated_at BEFORE UPDATE ON metrics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Seeds iniciais (exemplo)
-- INSERT INTO tenants (name, subdomain) VALUES ('Default Tenant', 'default');
-- INSERT INTO plans (name, description, features) VALUES ('Free', 'Plano gratuito', '{"max_users": 5, "storage_gb": 1}');
```
- **Observações sobre denormalização:** Não aplicável no schema básico apresentado.

## 11. Technology Stack Summary

- **Core Backend:** Node.js, Fastify, TypeScript (definido no PDR).
- **Workers:** Assíncronos (definido no PDR, biblioteca não especificada, `[ASSUMPTION]` BullMQ).
- **Database & Storage:** PostgreSQL, Prisma, Redis (implícito para workers e rate limiting).
- **Security:** JWT, bcrypt/argon2 (não definido explicitamente no PDR, mas `[ASSUMPTION]` implícito).
- **Observability:** Grafana, Prometheus (definido no PDR), Pino (implícito para logging estruturado).
- **External APIs:** Não mencionadas como parte integrante do *core* do boilerplate.

## 12. Deployment Architecture

- **Dev:** Docker Compose com postgres, redis, workers ([ASSUMPTION] baseado em stacks comuns e PDR).
- **Prod:** Kubernetes, RDS, ElastiCache ([ASSUMPTION] baseado em stacks comuns e PDR).
- **Scaling Strategy:** `[ASSUMPTION]` HPA por CPU/latência/fila (Kubernetes).

## 13. Cost Estimation (MVP)

- **Infraestrutura (AWS):** Não definido no PDR.
- **APIs externas:** Não aplicável ao escopo do boilerplate.
- **Custo por usuário:** Não definido no PDR.
- **Break-even analysis:** Não definido no PDR.

## 14. Migration Strategy (MVP → Production)

- **Fases:** MVP limitado ao painel administrativo base (definido no PDR).
- **Itens técnicos por fase:** RLS, seeds, observabilidade mínima implementada (definido no PDR). Sharding, tracing detalhado, compliance específica não mencionados como imediatos.

## 15. Open Questions & Assumptions Summary

1.  `[ASSUMPTION]` A ação em cascata para `ON DELETE` na FK `user.tenant_id` não é definida no PDR.
2.  `[ASSUMPTION]` O tempo de vida do JWT e a estratégia de refresh token não são definidos no PDR.
3.  `[ASSUMPTION]` A biblioteca específica para workers assíncronos (ex: BullMQ) não é definida no PDR.
4.  `[ASSUMPTION]` O valor padrão e o formato exato para o campo `min_similarity` (não existente no schema atual, mas mencionado como exemplo de regra) são irrelevantes aqui, mas o conceito de definição precisa se aplica.
5.  `[ASSUMPTION]` A implementação de 2FA é opcional para o MVP e sua estrutura não é definida.
6.  `[ASSUMPTION]` A criptografia em repouso para secrets usa AES-256-GCM.
7.  `[ASSUMPTION]` Headers de segurança como CSP, HSTS, X-Frame-Options são implementados.
8.  `[ASSUMPTION]` Testes de contrato (JSON Schema/Zod) são utilizados.
9.  `[ASSUMPTION]` Um endpoint `/health` é implementado.
10. `[ASSUMPTION]` Configurações de ambiente são separadas (dev/staging/prod).

## 16. API External Integration Reference

- Não aplicável ao escopo do Kaven Boilerplate conforme PDR.

## 17. Security Hardening Checklist

- Validação: RLS, políticas de senha, rate limiting (definido no PDR).
- Autenticação: JWT (definido no PDR).
- Autorização: Middleware + RLS (definido no PDR).
- Criptografia: Em trânsito (implícito), em repouso ([ASSUMPTION]).
- Rate limiting: Definido no PDR.
- CSP, dependências, secrets, monitoramento, compliance: `[ASSUMPTION]` implícito ou `[ASSUMPTION]` parte da implementação.

## 18. Final Notes

- Diferenciais arquiteturais: Multi-tenant com RLS, observabilidade mínima desde o início, estrutura modular.
- Prioridade de implementação: RLS, autenticação, observabilidade mínima, endpoints básicos.
- Caminho crítico pós-MVP: Integrações MCP, funcionalidades avançadas de observabilidade.
- Observabilidade e segurança desde o dia 1: Definido no PDR.

## 19. Quick Reference Tables

- Tabelas do DB: `tenants`, `users`, `plans`, `metrics`.
- Endpoints da API: `/auth/login`, `/users/me`, `/tenants`, `/metrics`.
- Workers e responsabilidades: Não definidos no PDR.
- APIs externas e custos: Não aplicáveis.
- Checklist de segurança: RLS, JWT, rate limiting, logs.

## 20. Implementation Checklist (Week-by-Week)

- Semana 1: Foundation (DB com RLS, auth JWT, logging estruturado).
- Semana 2: Endpoints básicos (CRUD tenants, users), Seeds iniciais.
- Semana 3: Observabilidade (Prometheus, Grafana), métricas básicas.
- Semana 4: Workers assíncronos (se necessário para MVP), testes básicos.

## 21. Monitoring & Alerting Configuration

- Prometheus scrape config: Para coletar métricas expostas pelo backend.
- Regras de alerta (exemplo): `time_response_per_tenant > 2s`, `errors_per_tenant > 100/hour`.
- Dashboard do Grafana: Visualizar as métricas definidas no PDR.

## 22. Disaster Recovery Plan

- Backup: Não detalhado no PDR, mas implícito para PostgreSQL.
- RTO/RPO: Não definido.
- Testes: Não definidos.

## 23. Compliance & Legal

- GDPR: Não detalhado no PDR, mas logs de auditoria e potencial para export/delete são relevantes.
- Termos de serviço: Não definidos.
- Política de conteúdo: Não aplicável ao boilerplate base.

## 24. Performance Optimization Roadmap

- MVP: Foco em funcionalidade e segurança.
- Futuro: Otimização de consultas, caching, escalabilidade horizontal.

## 25. Testing Strategy

- Unit, Integration, E2E, Load, Security: `[ASSUMPTION]` Estratégia a ser definida, mas implícita para um projeto robusto.