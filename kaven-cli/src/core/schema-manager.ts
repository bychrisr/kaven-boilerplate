import path from 'path';
import { logger } from '../lib/logger.js';
import { fsUtils } from '../lib/fs.js';

export class SchemaManager {
  private readonly basePath: string;
  private readonly extendedPath: string;
  private readonly outputPath: string;

  constructor(projectRoot: string) {
    // Default paths based on the new architecture
    this.basePath = path.join(projectRoot, 'packages/database/prisma/schema.base.prisma');
    this.extendedPath = path.join(projectRoot, 'packages/database/prisma/schema.extended.prisma');
    this.outputPath = path.join(projectRoot, 'packages/database/prisma/schema.prisma');
  }

  /**
   * Merge base and extended schemas into the final schema.prisma
   */
  async mergeSchemas(): Promise<void> {
    logger.info(`Source Base: ${this.basePath}`);
    logger.info(`Source Extended: ${this.extendedPath}`);
    logger.info(`Output: ${this.outputPath}`);
    logger.startSpinner('Merging Prisma schemas...');

    try {
      // Validation
      if (!(await fsUtils.exists(this.basePath))) {
        throw new Error(`Base schema not found at ${this.basePath}`);
      }

      // If extended schema doesn't exist, just use base (or create empty)
      const baseContent = await fsUtils.readFile(this.basePath);
      let extendedContent = '';

      if (await fsUtils.exists(this.extendedPath)) {
        extendedContent = await fsUtils.readFile(this.extendedPath);
      } else {
        logger.info('No extended schema found. Using base schema only.');
        // Optionally create the extended file template here
      }

      // perform simple concatenation for now, but a robust parser would be better
      // In a real framework, we would parse AST to avoid duplication of datasources/generators
      const mergedContent = this.performMerge(baseContent, extendedContent);

      await fsUtils.writeFile(this.outputPath, mergedContent);

      logger.succeedSpinner('Schemas merged successfully!');
    } catch (error) {
      logger.failSpinner('Schema merge failed');
      throw error;
    }
  }

  /**
   * Naive merge implementation
   * Removes datasource/generator from extended to avoid conflicts if they exist in both
   */
  private performMerge(base: string, extended: string): string {
    const HEADER = `// ⚠️ AUTOGENERATED FILE - DO NOT EDIT ⚠️\n// Modified content should go in schema.extended.prisma\n\n`;
    
    // Simplistic approach: Assume base has the datasource/generator blocks.
    // Strip them from extended if present to prevent errors.
    
    // Regex to remove datasource block
    const datasourceRegex = /datasource\s+\w+\s+\{[^}]+\}/g;
    // Regex to remove generator block
    const generatorRegex = /generator\s+\w+\s+\{[^}]+\}/g;

    let cleanExtended = extended
      .replace(datasourceRegex, '')
      .replace(generatorRegex, '');

    return HEADER + base + '\n\n// --- USER EXTENSIONS ---\n\n' + cleanExtended;
  }
}
